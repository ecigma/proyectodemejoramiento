\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage{pstricks,pst-grad,pst-plot,pst-coil}
\usepackage{graphicx}
\newpsobject{grilla}{psgrid}{subgriddiv=1,griddots=10,gridlabels=6pt}
\setlength{\textwidth}{18cm}
\setlength{\textheight}{23cm}
\setlength{\footskip}{1.5cm}
\oddsidemargin-1cm
\topmargin-1.5cm
\setlength{\parindent}{0pt}
\date{}
\renewcommand{\columnseprule}{0.05pt}
\begin{document}
	
	\begin{center}
	\textbf{Age Sort}\\
	
	\textbf{Johanna Beltran y Diego Triviño}\\
	
	2012
	\end{center}
	
	\vskip8cm
	
	\tableofcontents
	
	\vskip15cm
	
		\section {Introducción}
		
			\vskip0.5cm
		
			\textsl '\textbf{Age Sort}' es un problema de programación el cual encontramos en el juez virtual UVA con el número \textbf{11462}. 
			
			Este documento busca mostrar una de las tantas soluciones desde el enfoque matemático teniendo en cuenta que el objetivo es realizar la implementación de la solución del problema en cualquier lenguaje de programación con la ayuda de este documento.
			
			Este problema puede ser resuelto utilizando la estrategia de 'divide y vencerás'.
			
			Esta estrategia es una técnica de diseño de algoritmos la cual consiste en dividir de forma recurrente un problema en subproblemas más sencillos hasta que se encuentre un caso base. 
			
			\vskip1cm
			
			Esta técnica consta fundamentalmente de los siguientes pasos:
			
			\begin{enumerate}
			
				\item Descomponer el problema a resolver en un cierto número de subproblemas más pequeños.
				
				\item Resolver independientemente cada subproblema.
				
				\item Combinar los resultados obtenidos para construir la solución del problema original.
				
			\end{enumerate}
		
		\vskip4cm
		
		\section {Definición del problema}
		
			\vskip0.5cm
			
			Este problema implica clasificar todas las edades en orden ascendente.
		
			\vskip0.5cm
		
			Se deben tener en cuenta las siguientes restricciones para la solución del problema:
			
			\begin{enumerate}
			
				\item Para cada caso de prueba se debe ingresar un número $n$ y una secuencia de $n$ números enteros.
				
				\item Para $n$ se debe tener en cuenta que $1 \leq n \leq 2000000$ y que cada número que conforma la secuencia dada debe ser $1 \leq p \leq 100$ .
				
			\end{enumerate}
	 
	 	\vskip7cm
	
				\subsection {Entrada}
				
				\vskip0.5cm
				
					Hay varios casos de prueba en el archivo de entrada. Cada caso comienza con un entero $n$ $ \left(1 \leq n \leq 2000000)$ que indica el número total de personas. En la siguiente línea, deben haber $n$ números enteros que indican las edades. La entrada termina cuando $n = 0$, este caso no se debe tener en cuenta.
					
					\vskip0.5cm
					
					\[
					 	\emph{EJEMPLO}
					\]
					\[
					 		5
					\]
					\[
					 		3 \begin{tabular}{ccc} 4 \begin{tabular}{ccc} 2 \begin{tabular}{ccc} 1 \begin{tabular}{ccc} 5 \end {tabular} \end {tabular} \end {tabular} \end {tabular}
					\]
					\[
					 		5
					\]
					\[
					 		2 \begin{tabular}{ccc} 3 \begin{tabular}{ccc} 2 \begin{tabular}{ccc} 3 \begin{tabular}{ccc} 1 \end {tabular} \end {tabular} \end {tabular} \end {tabular}
					\]
					\[
					 		0
					\]
				
				\vskip2cm
				
				\subsection {Salida}
				
					\vskip0.5cm
				
					Para cada caso de prueba se debe imprimir una línea con $n$ enteros separados por espacios. Estos enteros son las edades ingresadas en orden ascendente.
					
					\vskip0.5cm
					
					\[
					 	\emph{EJEMPLO ANTERIOR}
					\]
					\[
							1 \begin{tabular}{ccc} 2 \begin{tabular}{ccc} 3 \begin{tabular}{ccc} 4 \begin{tabular}{ccc} 5 \end {tabular} \end {tabular} \end {tabular} \end {tabular}
					\]
					\[
							1 \begin{tabular}{ccc} 2 \begin{tabular}{ccc} 2 \begin{tabular}{ccc} 3 \begin{tabular}{ccc} 3 \end {tabular} \end {tabular} \end {tabular} \end {tabular}
					\]
	
			\vskip2cm
			
		\section {Modelamiento matemático}
		
		\vskip0.5cm
			
		Dado un número entero positivo $n$, se recibe una secuencia de $n$ números enteros: 
		
			\begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} \begin{tabular}{ccc} $E_{1}$, $E_{2}$, $E_{3}$, ..., $E_{n}$ \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular} \end {tabular}
					
				\vskip4cm
					
		\section {Planteamiento de la solución}
		
		\vskip0.5cm
		
			Para este problema utilizaremos el algoritmo de ordenamiento \textbf{Quicksort} que permite, en promedio, ordenar $n$ elementos en el menor tiempo posible; el algoritmo trabaja de la siguiente forma:
			
				\begin{enumerate}
				\includegraphics[width=0.50\textwidth]{quicksort2.png}
				
				\footnote{http://www.algolist.net/Algorithms/Sorting/Quicksort}
				
				\vskip1cm
				
				\item Elegir un elemento de la lista de elementos a ordenar, al que llamaremos pivote.
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort3.png}
				
				\footnote{http://www.algolist.net/Algorithms/Sorting/Quicksort}
				
				\vskip1cm
				
				\item Resituar los demás elementos de la lista a cada lado del pivote, de manera que a un lado queden todos los menores que él, y al otro los mayores. Los elementos iguales al pivote pueden ser colocados tanto a su derecha como a su izquierda, dependiendo de la implementación deseada. En este momento, el pivote ocupa exactamente el lugar que le corresponderá en la lista ordenada.
				
					\footnote{http://www.algolist.net/Algorithms/Sorting/Quicksort}
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort4.png}
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort5.png}
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort6.png}
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort7.png}
				
				\vskip1cm
				
				\item La lista queda separada en dos sublistas, una formada por los elementos a la izquierda del pivote, y otra por los elementos a su derecha.
				\item Repetir este proceso de forma recursiva para cada sublista mientras éstas contengan más de un elemento. Una vez terminado este proceso todos los elementos estarán ordenados. Como se puede suponer, la eficiencia del algoritmo depende de la posición en la que termine el pivote elegido.
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort8.png}
				
				\vskip1cm
				
				\includegraphics[width=0.50\textwidth]{quicksort9.png}
				
				\footnote{http://www.algolist.net/Algorithms/Sorting/Quicksort}
				
				\vskip1cm
						
						\item En el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es $O\left(n$ log $n)$.
						\item En el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de $O\left(n^{2})$. El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas.
				\end{enumerate}
							
			\vskip3cm
		
		\section {Conclusiones}
		
		\vskip0.5cm
		
			\begin{enumerate}
			
				\item Este algoritmo de ordenación es un ejemplo claro de que el método divide y vencerás es efectivo cuando tienes cantidades grandes de datos por trabajar y necesitas ahorrar tiempo y recursos.
				
				\item En el método de ordenación quicksort es mejor tener el pivote en el medio del vector puesto que es mas fácil de implementar y su código es mas sencillo.
			
			\end{enumerate}
	
\end{document}